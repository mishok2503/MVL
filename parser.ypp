%{
#include <iostream>
#include <string>
#include <map>
#include <set>
#include <cstdlib>
#include <unordered_map>
#include <exception>
#include <vector>
#include <fstream>
#include "structures.h"
node_body * main_body;
std::vector <node_func *> functions_definition;
int yylex(); 
void yyerror(const char *p) { std::cerr << "Syntax error! "<< std::endl; }
void output(node_func_call * func_call);
void output(std::vector <node_args> & args);
void output(node_args & arg);
/*
std::string output(node_operator * op) {
    std::stringstream ss;
    ss << "{\n";
    ss << "\"type\": \"operator\",\n";
    ss << "\"operator_type\": " << op->type << ",\n";
    ss << "\"operator\":"
    ss << output(op->if_st) << output(op->while_st) << output(op->skip_st) << output(op->assign) << output(op->func_call);
    ss << "}"
    return ss.str();
}

void output(node_func_call * func_call)
{
    if (!func_call) {
        return std::string{};
    }
    std::stringstream ss;
    ss << "{\n";
    ss << "\"TYPE\": \"FUNCTION CALL\",\n";
    ss << "\"FUNCTION_NAME\": " << func_call->func_name << ",\n";
    ss << "\"FUNCTION_ARGUMENTS\": ";
    output(func_call->args); 
    return ss.str();
}

void output(std::vector <node_args>& args){
    for (auto arg : args)
    {
        output(arg);
    }
}

void output(node_args& arg){
    std::cerr << "{\n";
    std::cerr << "\"TYPE\": \"ARGUMENT\",\n";
    std::cerr << "\"ARGUMENT_TYPE\": " << arg.type << ",\n";
    if (arg.type == "VARIABLE") {
        std::cerr << "\"VARIABLE_NAME\": " << arg.var_name;
    }
    else {
        std::cerr << "\"VALUE\": " << arg.value;
    }
    std::cerr << "}";
}
*/
%}

%union {
  std::string * word;
  int val; 
  char sym;
  std::vector <node_func *> * functions_def_type;
  std::vector <node_args> * func_args_type;
  std::vector <node_operator * > * operators_type;
  node_expr * expression_type;
  node_func * function_type;
  node_args * args_type;
  node_e * e_type;
  node_u * u_type;
  node_m * m_type;
  node_w * w_type;
  node_r * r_type;
  node_q * q_type;
  node_t * t_type;
  node_o * o_type;
  node_f * f_type;
  node_operation * operation_type;
  node_func_call * func_call_type;
  skip_op * skip_type;
  node_body * body_type;
  if_op * if_type;
  assignment_op * assignment_type;
  while_op * while_type;
  node_operator * operator_type;
  node_literal * literal_type;
};
%token <val> INT
%token <sym> OPEN_PAREN 
%token <sym> CLOSE_PAREN
%token <sym> CURLY_OPEN_BR
%token <sym> COMMA
%token <sym> CURLY_CLOSE_BR
%token <word> IF
%token <word> WHILE
%token <word> SKIP
%token <word> SW
%token <word> STRING
%token <sym> QUESTION
%token <word> AND
%token <word> OR
%token <sym> EXCLAM_P
%token <word> PLUS
%token <sym> OPM
%token <word> NOT_AS
%token <word> MINUS
%token <sym> DEGREE
%token <word> ELSE
%token <word> MAIN
%token <word> NAME_STRING
%token <sym> UNARY_MINUS
%token <word> INT2
%token <sym> COLON
%token <word> USER_OPERATOR

%type <functions_def_type> func_def
%type <function_type> function
%type <word> name
%type <func_args_type> args_seq
%type <operators_type> operator_sequence
%type <body_type> body
%type <body_type> else
%type <operator_type> operator 
%type <if_type> if
%type <while_type> while
%type <skip_type> skip
%type <assignment_type> assignment
%type <func_call_type> function_call
%type <expression_type> expression
%type <args_type> arg
%type <literal_type> literal
%type <operation_type> operation
%type <m_type> m
%type <e_type> e
%type <w_type> w
%type <u_type> u
%type <r_type> r
%type <q_type> q
%type <t_type> t
%type <o_type> o
%type <f_type> f  
%%

start: defin main {}

defin: func_def { functions_definition = *$1; }

func_def: %empty { $$ = new std::vector <node_func *>(); } 
| func_def function { $$->push_back($2); }

function: name OPEN_PAREN args_seq CLOSE_PAREN body { $$ = new node_func($1, $3, $5); }

body: CURLY_OPEN_BR operator operator_sequence CURLY_CLOSE_BR { $$ = new node_body($2, $3); }

main: MAIN OPEN_PAREN CLOSE_PAREN  body { main_body = $4; }

operator_sequence: %empty { $$ = new std::vector <node_operator *>(); } 
| operator_sequence operator { $$->push_back($2); }

operator: while { $$ = new node_operator($1); }
| if { $$ = new node_operator($1); }
| skip QUESTION { $$ = new node_operator($1); }
| assignment QUESTION { $$ = new node_operator($1); }
| function_call QUESTION { $$ = new node_operator($1); }

while: WHILE OPEN_PAREN expression CLOSE_PAREN body { $$ = new while_op($3, $5); }

if: IF OPEN_PAREN expression CLOSE_PAREN body else { $$ = new if_op($3, $5, $6); }

else: %empty { $$ = nullptr; }
| ELSE body { $$ = $2; }

skip: SKIP { $$ = new skip_op(); }

assignment: name SW expression  { $$ = new assignment_op($1, $3); }

function_call: name OPEN_PAREN args_seq CLOSE_PAREN { $$ = new node_func_call($1, $3); }

args_seq: %empty { $$ = new std::vector <node_args>(); }
| args_seq COMMA arg { $$->push_back(*$3); }
| arg {
    std::vector <node_args>* vec = new std::vector <node_args>();
    vec->push_back(*$1);
    $$ = vec;
}

arg: name { $$ = new node_args($1); }
| INT { $$ = new node_args($1); }

expression: operation { $$ = new node_expr($1); }

literal:  STRING { $$ = new node_literal($1); } 

operation: m { $$ = new node_operation($1); }

m: e OR m { $$ = new node_m($2, $1, $3); }
| e { $$ = new node_m($1); }

e: w AND e { $$ = new node_e($2, $1, $3); }
| w { $$ = new node_e($1); }

w: EXCLAM_P u { $$ = new node_w($1, $2); }
| u { $$ = new node_w($1); }

u: r NOT_AS r { $$ = new node_u($2, $1, $3); }
| r { $$ = new node_u($1); }

r: r PLUS q  { $$ = new node_r($2, $1, $3); }
| r MINUS q { $$ = new node_r($2, $1, $3); }
| q { $$ = new node_r($1); }

q: q OPM t { $$ = new node_q($2, $1, $3); } 
| t { $$ = new node_q($1); }

t: UNARY_MINUS o { $$ = new node_t($1, $2); }
| o { $$ = new node_t($1); }

o: f DEGREE o { $$ = new node_o($1, $3); } 
| f { $$ = new node_o($1); }

f: INT { $$ = new node_f($1); }
| INT2 { $$ = new node_f(1, $1); }
| name { $$ = new node_f(2, $1); }
| function_call { $$ = new node_f($1); }
| literal { $$ = new node_f($1); }

name: NAME_STRING { $$ = $1; }
%%

int main(int argc, char ** argv)
{
    freopen(argv[1], "r", stdin);
    try{
        yyparse();
    } catch(std::exception & e){
        std::cerr << e.what();
        fclose(stdin);
        return 1;
    }
    fclose(stdin);
   // output(main_body->first_op);
   // for (auto op : main_body->operators) {
     //   output(op);
   // }
}
